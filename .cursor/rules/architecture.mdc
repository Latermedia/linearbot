---
description: Project architecture and patterns
globs: ["src/**/*.ts", "src/**/*.svelte"]
alwaysApply: false
---

# Architecture

See [docs/architecture.md](../docs/architecture.md) for full details.

## Data Flow

```
Linear API → Sync Service → SQLite → SvelteKit API → Frontend
```

## Directory Structure

| Path | Purpose |
|------|---------|
| `src/routes/` | Pages + API endpoints |
| `src/lib/components/` | Svelte components |
| `src/lib/stores/` | Svelte stores |
| `src/db/` | Schema, queries, connection |
| `src/services/` | Sync + business logic |
| `src/linear/` | Linear API client |
| `terminal/` | Ink-based TUI |
| `scripts/` | CLI utilities |
| `src/**/*.test.ts` | Unit tests (colocated) |

## Patterns

- **Database**: Use `src/db/queries.ts` for all DB operations
- **API routes**: Return JSON, handle errors consistently
- **Sync**: `src/services/sync-service.ts` manages Linear data fetch
- **Stores**: Svelte stores in `src/lib/stores/` for shared state
- **Mock data**: When modifying `src/db/schema.ts`, update `src/services/mock-data.ts` to match

## Derived Data Pattern

Aggregate stats are computed during sync and stored in dedicated tables, NOT calculated on read.

### Why
- Fast reads: UI queries simple tables, no aggregation at runtime
- Consistent: All derived values computed once, same logic everywhere
- Cacheable: Stats update only on sync, not per request

### How to Add Derived Data

1. **Schema**: Add table in `src/db/schema.ts` for the entity (e.g., `engineers`)
2. **Queries**: Add CRUD functions in `src/db/queries.ts`
3. **Sync**: Add `computeAndStore<Entity>()` function in `sync-service.ts`:
   - Group raw `issues` by the entity key (e.g., `assignee_id`)
   - Calculate metrics, violation counts, aggregates
   - Store in dedicated table with `upsert<Entity>()`
4. **Call**: Invoke after issues are written, alongside `computeAndStoreProjects()`
5. **Mock**: Update `src/services/mock-data.ts` to generate matching mock records

### Example: Projects Table

```
Issues (raw) → computeAndStoreProjects() → Projects (derived)
                                            ├─ total_issues
                                            ├─ completed_issues
                                            ├─ velocity
                                            ├─ has_violations
                                            └─ ...
```

The frontend reads from `projects` table directly—no aggregation needed.
